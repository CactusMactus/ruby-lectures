= slide 'Днес' do
  list:
    Ruby core: `Struct`, `Comparable`, `Marshal`, `IO` & `File`
    `RubyVM::InstructionSequence`
    Ruby stdlib: `OpenStruct`
    Как да подхождаме към външни софтуерни зависимости
    Полезни Ruby библиотеки
    Съвети за проектите

= slide 'Предстоящи теми догодина' do
  list:
    Догодина продължаваме на 4 януари (понеделник)
    Първите две теми ще са "Паралелно програмиране" и "ОО-дизайн"
    Може би ще говорим още за тестване
    Имаме и няколко слота без фиксирана тема все още – приемаме предложения и въпроси за тях

= slide 'Изпитни дати и втори тест' do
  list:
    Вторият тест ще е по време на сесията
    Неделя, 31 януари 2016 г., от 10 ч. - втори тест и след него, първа дата за защита на проект
    Събота, 13 февруари, от 10 ч. - втора и последна възможна дата за защита на проект
    Все още очакваме потвърждение за тези дати и е възможно да има промяна

= slide 'Проекти', 'важни срокове' do
  list:
    Крайният срок да си изберете тема и <strong>да ви я одобрим</strong>, е четвъртък, <strong>24.12.2015</strong> г., 23:59:59
    [Ръководството за проекти](https://github.com/fmi/ruby-course-guides/blob/master/course_projects.md#readme) се обновява от време на време - следете за промени
    Направете прототип на проекта си, както ръководството съветва

= slide 'Прототипи' do
  list:
    В терминологията на XP (extreme programming) - spikes
    Пишете код, без да мислите за тестове, добър дизайн, архитектура, преизползване
    Гоните минимална цел и имате разумен времеви лимит
    Изследователска цел - опознаване на проблемната област и на избраните технологии
    След постигане на целта, прототипът се изоставя и се започва на чисто
    Освен всичко, носи и допълнителен стимул, когато видите нещо (частично) работещо

= slide 'Въпроси за проектите?' do
  p Ще продължим с Ruby core &amp; stdlib.

= slide 'Ruby core' do
  list:
    Ядрото на Ruby съдържа неща, които са част от интерпретатора и са винаги заредени и налични
    Друг поглед над това е, че винаги заемат памет и не можете да ги махнете
    Това е и причината немалка част от функционалността да е изведена в т.нар. "стандартна библиотека"
    Там са неща, които се ползват сравнително често, но <em>не винаги</em>
    Разглеждали сме повечето класове от `core`; сега ще видим още няколко интересни класа

= slide 'Struct' do
  list:
    Бърз начин да създавате мини-класове, представляващи колекция от атрибути
    Освен getter-и и setter-и за атрибутите, наподобяват малко на хеш
    [Документация на `Struct`](http://ruby-doc.org/core-2.1.5/Struct.html)

= slide 'Struct', 'пример от документацията' do
  p Виждате, че може да добавите и свои методи там

  annotate:
    Customer = Struct.new(:name, :address) do
      def greeting
        "Hello #{name}!"
      end
    end

    dave = Customer.new('Dave', '123 Main')

    dave.name     # =>
    dave.address  # =>
    dave.greeting # =>

= slide 'Struct' do
  p Обектите от тип <code>Struct</code> приличат на колекции (хешове):

  annotate:
    Customer = Struct.new(:name, :address, :zip)
    john = Customer.new('John Doe', '123 Maple, Anytown NC', 12345)

    john.name      # =>
    john['name']   # =>
    john[:name]    # =>
    john[0]        # =>

    john.length    # =>
    john.each      # =>

= slide 'Приложение на Struct' do
  p Удобно е да се ползва в тестове. За production код – по-рядко.

= slide 'Comparable' do
  list:
    Ползва се, когато имате наредба на инстанциите на вашия клас
    Дефинирате `<=>` и правите `include Comparable`
    Получавате `<`, `<=`, `==`, `>=`, `>` и `between?`

= slide 'Comparable', 'пример' do
  annotate:
    class Money
      include Comparable

      attr :amount, :currency

      def initialize(amount, currency)
        @amount, @currency = amount, currency
      end

      def <=>(money)
        return unless currency == money.currency
        amount <=> money.amount
      end
    end

    Money.new(15, :BGN) < Money.new(30, :BGN) # =>

= slide 'Marshal' do
  list:
    Може да се ползва за сериализиране и десериализиране на Ruby обекти
    Продуцира binary низ
    Проста употреба – `Marshal.load` и `Marshal.dump`
    Някои обекти не могат да бъдат сериализирани
    Може да предефинирате как (какво) да е представянето на ваш клас за сериализация
    За целта дефинирате методи `marshal_dump` и `marshal_load`
    Пълната му документация е [тук](http://ruby-doc.org/core-2.1.5/Marshal.html)

= slide 'Marshal', 'пример' do
  annotate:
    data = [42, :answer, {foo: 'bar'}]

    serizlized = Marshal.dump data

    serizlized                       # =>
    Marshal.load(serizlized) == data # =>
    Marshal.load(serizlized)         # =>

= slide 'Marshal', 'употреба и бележки' do
  list:
    Привидно удобен за употреба
    Съображения за сигурност при зареждане на серизлизирани данни "отвън"
    Може да доведе до изпълнение на произволен код
    За алтернатива на `Marshal` може да се ползва `YAML`, от стандартната библиотека
    YAML продуцира "човешки-четим" формат, но носи същите рискове за сигурността (и е бавничък)
    JSON, също част от стандартната библиотека, е човешки-четим, няколко пъти по-бърз от YAML и сигурен

= slide 'IO и File' do
  list:
    Все още не сме говорили за работа с файлове в Ruby
    Употребата е тривиална; достатъчно ви е да разгледате документацията на [`File`](http://ruby-doc.org/core-2.1.5/File.html) и [`IO`](http://ruby-doc.org/core-2.1.5/IO.html)
    `IO` е родителят на файл и представлява входно-изходен поток от данни
    Други класове, наследяващи от `IO` са `TCPSocket` и `UDPSocket`
    Много от методите на `File` идват от `IO`

= slide 'File - два примера' do
  p Прочитане на цял файл като низ:
  example:
    File.read('/etc/resolv.conf') # => "The contents of the file as a string."

  p Отваряне на файл, работа с обекта и автоматично затваряне на файла при излизане от блока:
  example:
    File.open('foo/bar.txt', 'w') do |file|
      file.write 'Some data.'
      file.puts  'Some other data, with a newline at the end.'
      file.puts  'File will be closed automatically, even in case of an exception in the block.'
    end

= slide 'RubyVM::InstructionSequence' do
  list:
    Не толкова полезен, колкото забавен клас
    Дава поглед към начина, по който парче Ruby код изглежда, компилиран в Ruby bytecode
    Специфичен за MRI (CRuby), може да го няма в други имплементации като JRuby, Rubinius и прочее
    [Документаця](http://ruby-doc.org/core-2.1.0/RubyVM/InstructionSequence.html)

= slide 'RubyVM::InstructionSequence', 'пример' do
  example:
    code = 'puts ["a" * 10].first'
    compiled = RubyVM::InstructionSequence.compile(code)
    puts compiled.disasm

  p Резултат:
  pre
    |
      == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled>@&lt;compiled>>==========
      0000 trace            1                                               (   1)
      0002 putself
      0003 putstring        "a"
      0005 putobject        10
      0007 opt_mult         &lt;callinfo!mid:*, argc:1, ARGS_SKIP>
      0009 newarray         1
      0011 opt_send_simple  &lt;callinfo!mid:first, argc:0, ARGS_SKIP>
      0013 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP>
      0015 leave

= slide 'RubyVM::InstructionSequence', 'още един пример' do
  example:
    puts RubyVM::InstructionSequence.compile('a, b = 1, 2').disasm

  p Можем да видим, че <code>a, b = 1, 2</code> минава през създаване на един обект тип <code>Array</code>:
  pre
    |
      == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled>@&lt;compiled>>==========
      local table (size: 3, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, keyword: 0@4] s1)
      [ 3] a          [ 2] b
      0000 trace            1                                               (   1)
      0002 duparray         [1, 2]
      0004 dup
      0005 expandarray      2, 0
      0008 setlocal_OP__WC__0 3
      0010 setlocal_OP__WC__0 2
      0012 leave

= slide 'Стандартната библиотека на Ruby' do
  list:
    Мислете за нея като за една купчина съвсем обикновени gem-ове, които вървят пакетирани с Ruby
    Част от нея е написана на C, друга част – на Ruby
    В [документацията на stdlib](http://ruby-doc.org/stdlib-2.1.0/) може да видите списъка с "gem"-ове
    За да ползвате нещо от нея, трябва да направите `require 'somelib'`, например `require 'bigdecimal'`
    Множество дребни и интересни библиотеки - разгледайте ги, за да знаете какво имате наготово

= slide 'Налични библиотеки' do
  pre
    |
      abbrev       base64          benchmark    bigdecimal          cgi            cmath
      coverage     csv             curses       date                dbm            debug
      delegate     digest          dl           drb                 e2mmap         English
      erb          etc             extmk        fcntl               fiddle         fileutils
      find         forwardable     gdbm         getoptlong          gserver        io/console
      io/nonblock  io/wait         ipaddr       irb                 json           logger
      mathn        matrix          minitest     minitest/benchmark  minitest/spec  mkmf
      monitor      mutex_m         net/ftp      net/http            net/imap       net/pop
      net/smtp     net/telnet      nkf          objspace            observer       open-uri
      open3        openssl         optparse     ostruct             pathname       pp
      prettyprint  prime           profile      profiler            pstore         psych
      pty          racc            racc/parser  rake                rdoc           readline
      resolv       resolv-replace  rexml        rinda               ripper         rss
      rubygems     scanf           sdbm         securerandom        set            shell
      shellwords   singleton       socket       stringio            strscan        sync
      syslog       tempfile        test/unit    thread              thwait         time
      timeout      tk              tmpdir       tracer              tsort          un
      uri          weakref         webrick      win32ole            xmlrpc         yaml
      zlib

= slide 'Какво сме ползвали досега от stdlib?' do
  list:
    bigdecimal
    benchmark
    minitest
    И много, много други, пряко и непряко...

= slide 'OpenStruct' do
  list:
    Ще разгледаме само един пример от stdlib - `OpenStruct`
    Наподобява хеш, но дава достъп до полетата си през методи
    Получавате го, като направите `require 'ostruct'`
    Имплементиран на Ruby, може да разгледате кода
    Дефинира `marshal_load` и `marshal_dump`, може да видите как за пример
    Имплементира и част от интерфейса на `Hash`, като `each_pair` и методите `[]` и `[]=`
    Вижте цялата му [документация](http://ruby-doc.org/stdlib-2.1.0/libdoc/ostruct/rdoc/OpenStruct.html)

= slide 'OpenStruct - пример' do
  annotate:
    require 'ostruct'

    john = OpenStruct.new
    john.name = 'John Doe'
    john.age  = 33

    john.name     # =>
    john.age      # =>
    john.address  # =>

= slide 'Полезни Ruby gem-ове и поуки' do
  list:
    Ще разгледаме някои популярни и полезни външни Ruby библиотеки
    По пътя ще се опитаме да научим нещо ново
    Например, добри практики при структуриране на проект
    "Boilerplate" неща, необходими на един Ruby gem или проект
    Други интересни Ruby трикове от практиката
    Но преди това...

= slide 'Third-party software – disclaimer' do
  p Долното е извадка от <a href="http://www.gnu.org/licenses/gpl.html">GNU GPL лиценза за отворен код</a>:

  blockquote
    p 15. Disclaimer of Warranty.
    p THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

    p 16. Limitation of Liability.
    p IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

= slide 'Third-party software – disclaimer' do
  p Долното е извадка от <a href="http://www.gnu.org/licenses/gpl.html">GNU GPL лиценза за отворен код</a>:

  blockquote
    p 15. Disclaimer of Warranty.
    p THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM <span style="outline: 4px solid red;">“AS IS” WITHOUT WARRANTY OF ANY KIND</span>, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

    p 16. Limitation of Liability.
    p IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

= slide '“AS IS” WITHOUT WARRANTY OF ANY KIND' do
  p.action Ние, програмистите, не вярваме на собствения си код, та какво остава за чуждия такъв?
  p.action Така и трябва. Колкото по-малко зависимости от чужд (third-party) код – толкова по-добре.
  p.action Изобщо, колкото по-малко код, откъдето и да е дошъл – толкова по-добре. Но това е друга тема.
  p.action От друга страна, не може да си напишем всичко. Трябва да стъпим на нещо. И трябва да знаем как да изберем на какво.

= slide 'Популярни gem-ове', 'статистика от rubygems.org' do
  p
    a href="https://rubygems.org/stats" rubygems.org/stats

  p.action Като изключим "помощни" gem-ове, най-популярният е Rails (с десетки милиони изтегляния)

= slide 'Откриване на нови Ruby Gems' do
  list:
    Статистики за популярни/най-използвани gem-ове (търсете в Google)
    [The Ruby Toolbox](https://www.ruby-toolbox.com/)
    Помощ от приятел

= slide 'Оценка качеството на съществуващи gem-ове' do
  list:
    Знаете името на gem и се чудите какво прави и дали е качествен?
    `rubygems.org/gems/именабиблиотеката` → линк "Source code" или "Homepage"
    Или търсите направо в GitHub
    Гледате колко хора са добавили и fork-нали проекта, откога е последния commit, дали има много issues и pull requests и прочее
    Разглеждате кода

= slide 'Инсталация под Windows' do
  list:
    Някои gem-ове използват C-разширения
    `gem install gemname --platform=ruby`
    RubyInstaller и Ruby DevKit – [http://rubyinstaller.org/](http://rubyinstaller.org/)

= slide 'RubyDoc' do
  list:
    [rubydoc.info](http://www.rubydoc.info/) - място за преглеждане на RDoc
    Генерирана документация от който и да е публикуван gem
    Ако не можете да откриете документацията на даден gem, проверете там

= slide 'Rails' do
  p
    a href="http://rubyonrails.org" rubyonrails.org

  list:
    Безспорно най-популярното нещо в Ruby света
    Добра отправна точка и [overview на Rails може да намерите в миналогодишните слайдове](http://2012.fmi.ruby.bg/lectures/15-ruby-on-rails-part-1#1)
    Тази година няма да говорим за него, но ще разгледаме някои негови компоненти

= slide 'RuboCop' do
  p
    a href="https://github.com/bbatsov/rubocop" https://github.com/bbatsov/rubocop

= slide 'Sidekiq' do
  p
    a href="https://github.com/mperham/sidekiq" https://github.com/mperham/sidekiq

= slide 'ActiveSupport' do
  p
    a href="https://github.com/rails/rails/tree/master/activesupport" https://github.com/rails/rails/tree/master/activesupport

  list:
    [Ръководство](http://guides.rubyonrails.org/active_support_core_extensions.html) - силно препоръчително

= slide 'ActiveRecord' do
  p
    a href="https://github.com/rails/rails/tree/master/activerecord" https://github.com/rails/rails/tree/master/activerecord

  list:
    ORM
    Може да работи с редица релационни бази данни - PostgreSQL, SQLite, MySQL и други
    Обикновено имате нужда и от съответния DB driver (пак gem) - например `mysql2`, `pg`, `sqlite3` и т.н.
    [Ръководство](http://guides.rubyonrails.org/active_record_basics.html) - силно препоръчително
    Може да се ползва извън Rails

= slide 'ActiveRecord-Sinatra' do
  p
    a href="https://github.com/janko-m/sinatra-activerecord" https://github.com/janko-m/sinatra-activerecord

= slide 'Curses', 'command-line UIs' do
  p
    a href="https://github.com/ruby/curses" https://github.com/ruby/curses

  list:
    Било е част от стандартната библиотека, вече е отделен gem
    [Документация](http://www.rubydoc.info/gems/curses)

= slide 'Thor' do
  p
    a href="https://github.com/erikhuda/thor" https://github.com/erikhuda/thor

= slide 'CarrierWave и Paperclip' do
  p
    a href="https://github.com/carrierwaveuploader/carrierwave" https://github.com/carrierwaveuploader/carrierwave
  p
    a href="https://github.com/thoughtbot/paperclip" https://github.com/thoughtbot/paperclip

= slide 'Kaminari и will_paginate' do
  p
    a href="https://github.com/amatsuda/kaminari" https://github.com/amatsuda/kaminari
  p
    a href="https://github.com/mislav/will_paginate" https://github.com/mislav/will_paginate

= slide 'MiniMagick' do
  p
    a href="https://github.com/minimagick/minimagick" https://github.com/minimagick/minimagick

= slide 'CanCan' do
  p
    a href="https://github.com/ryanb/cancan" https://github.com/ryanb/cancan

= slide 'Devise' do
  p
    a href="https://github.com/plataformatec/devise" https://github.com/plataformatec/devise

= slide 'Bcrypt-Ruby' do
  p
    a href="https://github.com/codahale/bcrypt-ruby" https://github.com/codahale/bcrypt-ruby

= slide 'ActiveAdmin' do
  p
    a href="https://github.com/gregbell/active_admin" https://github.com/gregbell/active_admin

= slide 'Nokogiri' do
  p
    a href="https://github.com/sparklemotion/nokogiri" https://github.com/sparklemotion/nokogiri

= slide 'SASS' do
  p
    a href="https://github.com/nex3/sass" https://github.com/nex3/sass

= slide 'SimpleForm и Formtastic' do
  p
    a href="https://github.com/plataformatec/simple_form" https://github.com/plataformatec/simple_form
  p
    a href="https://github.com/justinfrench/formtastic" https://github.com/justinfrench/formtastic

= slide 'Capistrano' do
  p
    a href="https://github.com/capistrano/capistrano" https://github.com/capistrano/capistrano
  p.action Deploy WordPress with Capistrano!

= slide 'Passenger, Unicorn, Thin, Puma' do
  p
    a href="https://github.com/phusion/passenger" https://github.com/phusion/passenger

= slide 'Fog' do
  p
    a href="https://github.com/fog/fog" https://github.com/fog/fog

= slide 'Bundler' do
  p
    a href="https://github.com/bundler/bundler" https://github.com/bundler/bundler
    '  или
    a href="http://bundler.io/" http://bundler.io

  p.action Практически задължително за всеки проект, който има нужда от други gem-ове.
  list:
    Грижи се за две неща - инсталация на правилната версия на всички зависимости
    Зареждане на правилната версия на всички зависимости

= slide 'Обобщение' do
  list:
    По света има много gem-ове, за почти всичко
    Трябва да може да откривате такива и да оценявате качеството им
    Не трябва да им се предоверявате
    Разровете се в кода и структурата на тези gem-ове
    Ще научите много от кода и практиката на другите

= slide 'String#%', 'бонус слайдове' do
  list:
    Методът `%` на `String` е много удобен за интерполация и форматиране на определени низове
    Тази функционалност е позната още като "sprintf"
    Подробна документация за нея може да се намери в [`Kernel.sprintf`](http://ruby-doc.org/core-2.1.0/Kernel.html#method-i-sprintf)
    Два основни режима на работа – с позиционни и с именувани placeholder-и
    `%` може да се ползва и без точка, като други методи, наподобяващи оператори

= slide 'String#%', 'пример с позиционни аргументи' do
  p Когато имаме повече от една стойност за интерполация, трябва да подадем списък:

  annotate:
    '%02d' % 7                             # =>
    '%02d:%02d:%02d' % [19, 5, 2]          # =>

    name = 'Пешо'
    'Здравей, <strong>%s</strong>!' % name # =>

= slide 'String#%', 'пример с именувани аргументи' do
  annotate:
    template = '
      <html>
      <head>
        <title>%{title}</title>
      </head>
      <body>
        %{content}
      </body>
      </html>
    '

    variables = {
      title:   'String Interpolation',
      content: 'Made easy by Kernel.sprintf.',
      foobar:  'Extra keys are not an issue.'
    }

    template % variables # =>
