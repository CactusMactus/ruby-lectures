= slide 'Контролно' do
  list:
    2 декември (сряда), зала 200
    Четни - 19:00
    Нечетни - 20:00
    30 въпроса, 45 минути

= slide 'Днес' do
  list:
    Ще се забавляваме с регулярни изрази (очевидно)
    Регулярните изрази в бита на програмиста
    Как да ги ползваме в Ruby код
  div.action
    annotate:
      /find me/.match 'Can you find me here?' # =>

= slide 'Кой...?' do
  list:
    ...е карал/кара Езици, автомати, изчислимост?
    ...знае за `.`, `\w`, `\d`, `+`, `*`, `?` и още +/-3?
    ...е виждал пълната им фунционалност в друг език?
    ...може да прочете произволен регулярен израз?

= slide 'Stand back...' do
  a href="http://xkcd.com/208/"
    img src="14/regular_expressions.png"
    p style="text-align: center;"
      small
        em Wait, forgot to escape a space. Wheeeeee[taptaptap]eeeeee.

= slide 'Знам регулярни изрази!', 'За просветените в тайнството...' do
  list:
    Чували сте за регулярни изрази?
    Чувствате се умели в употребата им?
    Страхувате се, че ще ви е скучно днес?
    Ето ви дребни задачки, за да не ви е скучно

= slide 'Традиционната задача', 'за тези от вас, които се чувстват комфортно с РИ' do
  p Имаме следната задача:
  blockquote
    | Да се напише кратък Ruby expression, който проверява дали дадено число е просто или не,
      посредством употреба на регулярен израз. Резултатът от изпълнението му трябва да е <code>true</code>
      за прости числа и <code>false</code> за всички останали. Неща, които можете да ползвате:
    list:
      Самото число, разбира се.
      Произволни методи от класа `Regexp`
      Подходящ регулярен израз (шаблон)
      Текстовия низ `'1'`.
      `String#*`.
      Някакъв условен оператор (например `if`-`else` или `? … : …`)
      `true`, `false`, ...
  list:
    Материалът, необходим за решаването й, ще го има изцяло в днешната лекция.

= slide 'И още една задача', 'за тези от вас, които вече ни знаят номерата' do
  p Имаме следната задача:
  blockquote
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чийто резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се

= slide 'И още', 'за тези от вас, които вече ни знаят номерата' do
  blockquote
    | Сменете * на % ако тя не е екранирана (escape-ната)
    list:
      `foo*`     => `foo%`
      `foo\*`    => `foo\*`
      `foo\\\\*` => `foo\\\\%`
      `*\**`    => `%\*%`
      Може и да стане без look-ahead/behind/... :)

= slide 'MOAR, MOAR!!!!111!', 'за тези от вас, които вече ни знаят номерата' do
  blockquote
    | Проверете дали нещо е валиден математически израз
    list:
      Произволно число цяло `1337`
      Променлива (латинска малка буква) `x`
      Операция между валидни изрази (+, -, *, /) `x + y - 21 / 3`
      Скоби, ограждащи валидни изрази `-x * (y + -5 * (7 - 13)) / 44 - 9000`
  list:
    Ще обсъдим възможните решения и задачите по-късно в рамките на днешната сбирка.

= slide 'Disclaimer' do
  blockquote
    em Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.

= slide '...summons tainted souls into the realm of the living...' do
  a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags"
    img src="14/xhtml_tags_regex.png"
    p style="text-align: center;"
      small
        em will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror

= slide 'Произход', 'малко обща култура' do
  list:
    На възраст над 60 години (Клини, regular sets, ок. 1950 г.)
    Practical Extraction and Report Language
    Perl и PCRE-библиотеката (Perl-Compatible Regular Expressions)
    Почти всеки general-purpose програмен език имплементира някаква форма на РИ
    Незаменими unix-програми като `grep`, `sed`, `awk`, `vi`, `Emacs`...
    Разглеждат се в курса по Езици, автомати, изчислимост

= slide 'Проблемна област', 'най-общо: работа с текстови низове' do
  list:
    Търсене на по-сложна последователност от символи в низ
    Заместване на такива последователности с нещо друго
    Модифициране на текстови последователности (например, Markdown към HTML)
    Проверка дали даден низ отговаря на определени условия (валидация)
    Проверка дали едно число е просто или не :) Не.

= slide 'Понятия', 'и терминология' do
  list:
    „шаблон“, още „регулярен израз“ (pattern)
    Специални символи (meta characters)
    Екраниране на специалните символи (escape-ване)
    Повторители и повторение (quantifiers and repetition)
    Класове от символи (character classes)
    Групи
    Флагове (modifiers) на шаблона

= slide 'РИ в Ruby', 'синтаксис, накратко' do
  list:
    Всеки регулярен израз е обект, инстанция на класа `Regexp`
    Има литерален синтаксис за създаване на регулярни изрази: `/pattern/`
    Може да се ползва и синтаксисът с `%r`, например: `%r{/path/maching/made/easy}`
    Операциите с регулярни изрази са методи на `Regexp`
    Класът `String` също има методи за работа с регулярни изрази

= slide 'Regexp#match', 'ще го ползваме в примерите' do
  list:
    За да демонстрираме какво "хващат" определени шаблони, ще ползваме `Regexp#match`
    Този метод примема аргумент текстов низ и връща `nil`, ако шаблонът не "хваща" нищо
    Връща инстанция на `MatchData`, ако шаблонът "хваща" нещо от низа
    `MatchData` в детайли — по-късно
    От тук нататък ще ползваме <em>match-ва</em> като синоним на <em>"хваща"</em> :)

= slide 'Шаблони', '(регулярни изрази, patterns и т.н.)' do
  list:
    В сърцето на всеки регулярен израз стои шаблон (pattern)
    В шаблона, всеки символ (освен някои специални) означава себе си
    Следователно, шаблонът `/wool/` ще отговаря на точно тази последователност от символи в низ
    Цялата магия е в специалните символи:
    `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`, `+`, `*`, `^`, `$`, `\`, ...
    Някои символи са специални само в определен контекст (например символът `-`)

= slide 'Най-прост пример' do
  annotate:
    /find me/.match 'Can you find me here?' # =>
    /find me/.match 'You will not find ME!' # =>
  list:
    Този шаблон не съдържа специални символи
    Както виждате, по подразбиране шаблоните са чувствителни към регистъра на буквите
    Последното може да се контролира с помощта на флагове към шаблона

= slide 'Специални символи', 'meta characters' do
  list:
    `.` съвпада с един произволен символ (с изключение на символите за нов ред)
    `[` и `]` се ползват за дефиниране на класове от символи
    `*`, `?`, `+`, `{` и `}` се ползват за указване на повторения
    `^`, `$`, `\b`, `\B` и т.н. са "котви" и съответстват на определени "междусимволни дупки" :)
    `|` има смисъл на "или", например:
  div.action
    annotate:
      /day|nice/.match  'A nice dance-day.'  # =>
      /da(y|n)ce/.match 'A nice dance-day.'  # =>

  p.action Внимавайте с приоритета на <code>|</code>

= slide 'Екраниране', 'на специалните символи (escape-ване)' do
  list:
    `\` пред специален символ го прави неспециален такъв (екранира го)
    За да вкарате наклонена черта, ползвате `\\` (като в обикновен низ)

= slide 'Класове от символи', '(character classes)' do
  list:
    Заградени между `[` и `]`
    Наподобяват множества
    Match-ват един символ от посочените вътре
    Могат да се декларират диапазони, например `[a-z]` или `[0-9A-F]`
    Можете да екранирате тире в символен клас така: `[a\-b]`
    Друг вариант е да сложите тирето в началото или в края на класа: `[-abc]` или `[abc-]` - тук то няма специален смисъл
    Ако първият символ в класа е `^`, това означава "някой символ, който не е посочен в класа"
    Има предефинирани класове от символи

= slide 'Примери с класове от символи' do
  annotate:
    /W[aeiou]rd/.match "Word" # =>
    /[0-9a-f]/.match '9f'     # =>
    /[9f]/.match     '9f'     # =>
    /[^a-z]/.match   '9f'     # =>

= slide 'Предефинирани класове от символи' do
  list:
    `\w` - символ от дума (`[a-zA-Z0-9_]`)
    `\W` - символ, който не може да участва в дума (`[^a-zA-Z0-9_]`)
    `\d` - цифра (`[0-9]`)
    `\D` - символ, който не е цифра (`[^0-9]`)
    `\h` - шеснадесетична цифра (`[0-9a-fA-F]`)
    `\H` - символ, който не е шеснадесетична цифра (`[^0-9a-fA-F]`)
    `\s` - whitespace-символ (`/[ \t\r\n\f]/`)
    `\S` - символ, който не е whitespace (`/[^ \t\r\n\f]/`)

= slide 'POSIX-класове от символи' do
  list:
    `[[:alpha:]]` - символ от азбука
    `[[:alnum:]]` - горното или цифра
    `[[:blank:]]` - интервал или таб
    `[[:cntrl:]]` - контролен символ
    `[[:digit:]]` - цифра
    `[[:lower:]]` - малка буква
    `[[:upper:]]` - главна буква
    `[[:print:]]` - printable-символ
    `[[:punct:]]` - пунктуационен символ
    `[[:space:]]` - whitespace-символ (вкл. и нов ред)
    `[[:xdigit:]]` - шеснадеситична цифра
    И други...

= slide 'Полезни не-POSIX класове' do
  list:
    Ruby поддържа и следните не-POSIX символни класове:
    `[[:word:]]` - символ, който може да участва в дума (работи и за Unicode, за разлика от `\w`)
    `[[:ascii:]]` - ASCII-символ

= slide 'Символни свойства', 'character properties' do
  list:
    С конструкцията `\p{}` може да match-вате символи, имащи определено свойство (подобно на POSIX)
    Например: `\p{Alnum}`, `\p{Alpha}`, `\p{Blank}`, `\p{Cntrl}`, `\p{Digit}`, `\p{Graph}`
    По този начин, например, може да проверите дали даден символ е от японската азбука катакана: `\p{Katakana}`
    Или пък да match-нете символ от азбука на кирилица: `\p{Cyrillic}`, например:

  div.action
    annotate:
      /\s\p{Cyrillic}\p{Cyrillic}\p{Cyrillic}/.match 'Ние сме на всеки километър!' # #<MatchData " сме">

= slide 'Котви' do
  list:
    Не съвпадат с реални символи, а вместо това с невидимите граници между тях
    `^` съвпада с началото на ред (Ruby е в multiline режим по подразбиране)
    `$` съвпада с края на ред
    `\A` съвпада с началото на текстов низ
    `\z` съвпада с края на низ
    `\b` отговаря на граница на дума (когато е извън `[` и `]`; вътре означава `backspace`)
    `\B` отговаря на място, което не е граница на дума

= slide 'Примери с котви' do
  annotate:
    /real/.match "surrealist"    # =>
    /\Areal/.match "surrealist"  # =>
    /\band/.match "Demand"       # =>

    /\Band.+/.match "Supply and demand curve" # =>

= slide 'Повторители', '(quantifiers)' do
  list:
    Важат за непосредствено предхождащия ги символ/клас/група; нека го означим със `s`
    `s*` означава нула или повече повторения на `s`
    `s+` търси едно или повече повторения на `s`
    `s?` съвпада с нула или едно повторение на `s`
    `s{m,n}` означава между m и n повторения на `s`
    В последното можем да пропуснем `m` или `n`:
    `s{,n}` има смисъл на нула до `n` повторения, а `s{m,}` — поне `m` повторения
    `s{n}` означава точно `n` повторения

= slide 'Примери с повторители' do
  annotate:
    /e+/.match     'Keeewl'       # =>
    /[Kke]+/.match 'Keeewl'       # =>
    /\w+/.match '2038 - the year' # =>
    /".*"/.match '"Quoted text!"' # =>

    /[[:upper:]]+[[:lower:]]+l{2}o/.match 'Hello' # =>

= slide 'Алчност', 'и лакомия...' do
  list:
    По подразбиране повторителите са "алчни", т.е. изяждат колкото се може повече от низа
    Това поведение може да се контролира с `?` след повторителя
    Например `.*?` кара повторителя `*` да се държи не-лакомо
    Внимавайте с лакомите повторители
  div.action
    annotate:
      /<.+>/.match("<a><b>")  # =>
      /<.+?>/.match("<a><b>") # =>

= slide 'Групи', 'и прихващане' do
  p Символите <code>(</code> и <code>)</code> се използват за логическо групиране на части от шаблона с цел:
  list:
    Контролиране областта на влияние на дадена операция
    Например, следното ще match-ва низове, съдържащи думите `day` или `dance`: `/\bda(y|nce)\b/`
    Възможност за референция към „ограденото“ в скобите — в и извън шаблона
    Задаване на по-специални (и не толкова често употребявани) конструкции
    Групите биват номерирани или именовани

= slide 'Референции към групи' do
  p Текстът, който match-ва частта на шаблона, оградена в скоби, може да се достъпва:
  list:
    В самия шаблон, с нотацията `\1` за първата група, `\2` за втората и т.н.
    Отвън, през `MatchData`-обекта
    Отвън, през специални променливи от типа на `$1`, `$2`... за номерирани групи
    Отвън, през локални променливи, за именовани групи

= slide 'Референции към групи', 'извън шаблона, за номерирани групи, през MatchData' do
  example:
    date_string = '2015-11-30'
    date_parts  = /\A(\d{4})-(\d\d)-(\d\d)\z/.match(date_string)

    if date_parts
      Date.new date_parts[1].to_i, date_parts[2].to_i, date_parts[3].to_i
      # #<Date: 2015-11-30 ...>
    end

= slide 'Пропускане на уловени групи' do
  list:
    Понякога ни се налага да използваме групи за примерно "или" `(foo|bar)`, но не искаме тази група да се намесва в `$1`, `$2`, ...
    Това правим чрез `(?:foo|bar)`
  div.action
    annotate:
      /(\d+)(st|nd|rd|th)? (\w+)/.match '1st June' # =>
      /(\d+)(?:st|nd|rd|th)? (\w+)/.match '1st June' # =>
      /(\d+)(st|nd|rd|th)? (\w+)/.match '1 June' # =>
      /(\d+)(?:st|nd|rd|th)? (\w+)/.match '1 June' # =>

= slide 'if с регулярни изрази' do
  list:
    `=~` и `!~` — дефинирани в `Regexp` и в `String`
    Можем да правим така: `/pattern/ =~ 'Some string'`
    Както и така: `'Some string' =~ /pattern/`
    Връща `nil`, ако няма съвпадение, или число (offset), ако има такова
    След изпълнение на този оператор също имаме попълнени специални променливи (`$1`, `$~`...)
    Удобно е да се ползва в условни конструкции, например `if`

= slide 'if с регулярни изрази', 'пример' do
  annotate:
    log_entry = "[2011-07-22 15:42:12] - GET / HTTP/1.1 200 OK"

    if log_entry =~ /\bHTTP\/1\.1 (\d+)/
      request_status = $1.to_i # =>
    else
      raise "Malformed log entry!"
    end

= slide 'Референции към групи', 'извън шаблона, за номерирани групи, през $1, $2...' do
  example:
    date_string = '2015-11-30'

    if date_string =~ /\A(\d{4})-(\d\d)-(\d\d)\z/
      Date.new $1.to_i, $2.to_i, $3.to_i # #<Date: 2015-11-30 ...>
    end

= slide 'Именовани групи' do
  list:
    Като обикновена група, само че се обръщате към тях не с цифра, а с име
    Дефинират се така: `(?&lt;name&gt;)` или така: `(?'name')`, където `name` е името на групата
    Например: `(?&lt;date&gt;\d{4}-\d{2}-\d{2})`
  div.action
    annotate:
      /(?<date>\d{4}-\d{2}-\d{2})/.match 'Today is 2011-11-08, Tuesday.' # =>

= slide 'Референции към групи', 'в рамките на шаблона' do
  list:
    `\1`, `\2` и прочее, ако групите ви не са именовани
    Ако имате повече от 9 групи, можете да ги реферирате по същия начин:
    `\11` се обръща към 11-тата група
    Ами ако искам да кажа: "текстът, отговарящ на група `\1`, последван от символа `1`"?
    Ползвате следния общ синтаксис: `\k&lt;group_identifier&gt;`, където `group_identifier` е число или име на група
    Този общ синтаксис се използва и за обръщение към текста, отговарящ на именовани групи:
    `/(?&lt;word&gt;\w+), \k&lt;word&gt;/`

= slide 'Примери за референции към групи' do
  example:
    /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/.match 'Today is 2011-11-08, Tuesday.'
    # #<MatchData "2011-11-08" year:"2011" month:"11" day:"08">

    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/.match 'Regular expressions'
    # #<MatchData "ular express" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\k<11>1/.match 'Regular express1ions'
    # #<MatchData "ular express1" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">

  list:
    Забележете, че в рамките на един шаблон <strong>не може</strong> да ползвате и двата вида рефериране към групи

= slide 'Уточнение относно референциите', 'в рамките на шаблона' do
  list:
    Обърнете внимание, че референцията е към порцията текст, match-нат от групата, а не към самата група!
    Например:
  div.action
    annotate:
      /(\w+), \1/.match 'testing, testing' # =>
      /(\w+), \1/.match 'testing, twice'   # =>

      /(?<word>\w+), \k<word>/.match 'testing, testing' # =>

= slide 'Backtracking' do
  list:
    Често срещан термин в регулярните изрази, свързан с имплементацията им
    Често се случва, когато имате "алчни" повторители
    Ето пример как работи:

  .action
    annotate:
      /".*"/.match '"Quoted"' # =>

    p Частта от шаблона <code>.*</code> хваща <code>Quoted"</code>, тъй като е алчна. Това води до невъзможност да се намери съвпадение и алгоритъмът backtrack-ва -- връща се една стъпка/символ назад.

= slide 'Атомарни (неделими) групи' do
  list:
    Атомарните (неделими) групи могат да променят това поведение
    Атомарна група се дефинира така: `(?>pattern)`
    Според документацията, се ползват за оптимизация и предотвратяване на излишно backtrack-ване
    Например:

  .action
    annotate:
      /"(?>.*)"/.match('"Quote"') # =>

= slide 'Рекурсивни групи' do
  list:
    Ако вместо порцията текст, отговаряща на дадена група, искате да преизпълните групата?
    Ползвате следния синтаксис: `\g&lt;name&gt;`, където `name` е номер или име на група в шаблона
    Това <strong>преизпълнява</strong> шаблона, не търси за вече намерения текст
    Има смисъл за да направи шаблоните ви една идея по-DRY
    Например:
  div.action
    annotate:
      /(\w+), \1/.match    'testing, twice'   # =>
      /(\w+), \g<1>/.match 'testing, twice'   # =>

= slide 'Рекурсивни групи', 'втора част' do
  list:
    С помощта на горното можете да дефинирате рекурсивни групи
    Спомняте ли си втория проблем, който поставихме в началото?
  blockquote.action
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чийто резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се

= slide 'Примерно решение', 'с рекурсивни групи' do
  annotate:
    validator = /^(\(car (\g<1>*|\w*)\))$/

    valid   = '(car (car (car (car list))))'
    invalid = '(car (car (car list))'

    validator.match(valid)   ? true : false # =>
    validator.match(invalid) ? true : false # =>

= slide 'MOAR, MOAR!!!!111!' do
  blockquote
    | Проверете дали нещо е валиден математически израз
    list:
      Произволно цяло число `1337`
      Променлива (малка латинска буква) `x`
      Знак пред валиден израз (+, -) `-33 + 22 * -y`
      Операция между валидни изрази (+, -, *, /) `x + y - 21 / 3`
      Скоби, ограждащи валидни изрази `-x * (y + -5 * (7 - 13)) / 44 - 9000`

= slide 'Примерно решение', 'so simple, right?' do
  example:
    validator = /^([-+]?(\d+|[a-z]|\(\g<1>\)|\g<1> [-+*\/] \g<1>))$/

    valid   = '-(3 + (x * (7 / y))) * (44 * y - z / 22)'
    invalid = '((33 - 7) * x'

    validator.match(valid)   ? true : false
    validator.match(invalid) ? true : false

= slide 'Примерно решение', 'nope... fail!' do
  annotate:
    /^([-+]?(\d+|[a-z]|\(\g<1>\)|\g<1> [-+*\/] \g<1>))$/

= slide 'Примерно решение', 'с рекурсивни групи' do
  annotate:
    validator = /^([-+]?(\d+|[a-z]|\(\g<1>\))( [-+*\/] \g<1>)?)$/

    valid   = '-(3 + (x * (7 / y))) * (44 * y - z / 22)'
    invalid = '((33 - 7) * x'

    validator.match(valid)   ? true : false # =>
    validator.match(invalid) ? true : false # =>

= slide 'Look-ahead и look-behind' do
  list:
    Положителен look-ahead: `/(?=pattern)/`
    Отрицателен look-ahead: `/(?!pattern)/`
    Положителен look-behind: `/(?&lt;=pattern)/`
    Отрицателен look-behind: `/(?&lt;!pattern)/`
    Пример:
  div.action
    annotate:
      /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>") # =>

= slide 'Пример' do
  blockquote
    | Сменете * на % ако тя не е екранирана (escape-ната)
    list:
      `foo*`     => `foo%`
      `foo\*`    => `foo\*`
      `foo\\\\*` => `foo\\\\%`
      `*\\\**`    => `%\\\*%`

= slide 'Първи начин' do
  div.action
    annotate:
      "*\\**".gsub(/((?<!\\)(?:\\\\)*)\*/, '\1%') # =>
  list:
    Група 1 евентуално държи четни наброй `\`, които нямат пред себе си `\`
    После ловим `*` и готово :)

= slide 'Втори начин' do
  div.action
    annotate:
      "*\\**".gsub(/\G([^*\\]*(?:\\.[^*\\]*)*)\*/, '\1%') # =>
  list:
    Сложно...

= slide 'Интерполация в регулярни изрази' do
  p Между другото, регулярните изрази поддържат интерполация:

  annotate:
    name      = /[^@]+/
    host      = /\w+\.(com|net|org)/

    email     = /#{name}@#{host}/ # =>

= slide 'Работа с MatchData-обекти' do
  list:
    Това е обектът, който ви връща `Regexp#match`
    Това е обектът, стоящ зад специалната променлива `$~`
    Същият обект се крие и зад `Regexp.last_match`
    Не е `Enumerable`

= slide 'Най-полезни методи на MatchData-обектите' do
  list:
    `MatchData#[група]`, където `група` е номер или име на група, ви връща порцията текст, отговаряща на съответната група
    `MatchData#begin(група)` пък ви връща число — отместването спрямо началото на низа на порцията текст, отговаряща на съответната група
    Пример:
  div.action
    annotate:
      /(\w+)/.match('Some words')[1]              # =>
      /(\w+)/.match('Some words').begin(1)        # =>
      /(?<id>\d+)/.match('ID: 12345')[:id]        # =>
      /(?<id>\d+)/.match('ID: 12345').begin(:id)  # =>

= slide '#pre_match и #post_match методи', 'на MatchData-обектите' do
  list:
    `MatchData#pre_match` (същото като специалната променлива <code>$`</code>) — текстът преди съвпадението
    `MatchData#post_match` (същото като специалната променлива <code>$'</code>) — текстът след съвпадението
    Пример:
  div.action
    annotate:
      match = /(?<number>\d+)/.match 'ID: 12345 (new)'

      match[:number]    # =>
      match.pre_match   # =>
      match.post_match  # =>

= slide 'Специалните променливи' do
  list:
    `$~`, `$'`, `$1`, `$2`, `$3` и прочее
    Не са глобални променливи, а специални - thread-local и method-local, т.е. не са глобално-видими
    Попълват се с резултата от последно изпълнения `match`
    Не само след явно извикване на `Regexp#match`

= slide 'case с регулярни изрази', 'работи благодарение на Regexp#===' do
  example:
    html = '<h1>Header</h1>' # или:
    html = '<img src="http://my/image.src" alt="Kartman Makes Burgers" />'

    case html
      when /(<h(\d)>)(.+)<\/h\2>/
        {header: $3, size: $2}
      when /<a\s+href="([^"]+)">([^<]+)<\/a>/
        {url: $1, text: $2}
      when /<img\s+src="([^"]+)"\s+alt="([^"]+)"\s*\/>/
        {image: $1, alt: $2}
      else
        'unrecognized tag'
    end

    # {:image=>"http://my/image.src", :alt=>"Kartman Makes Burgers"}

= slide 'Методи в String', 'свързани с регулярни изрази' do
  list:
    `String#match`
    `String#=~` и `String#!~`
    `String#sub`, `String#gsub` и вариантите им с `!`
    `String#[]` и `String#slice` - в някои от вариантите си приемат регулярен израз
    `String#index` и `rindex` приемат и регулярен израз
    `String#partition` и `rpartition` и <a href="http://www.ruby-doc.org/core-2.2.3/String.html">други...</a>

= slide 'Пример със String#gsub', 'плюс групи и блок' do
  example:
    'SomeTitleCase'.gsub /(^|[[:lower:]])([[:upper:]])/ do
      [$1, $2.downcase].reject(&:empty?).join('_')
    end

    # "some_title_case"

= slide 'Encoding' do
  p Цитат от документацията:
  blockquote
    |
      A regexp can be matched against a string when they either share an encoding,
      or the regexp’s encoding is US-ASCII and the string’s encoding is ASCII-compatible.

= slide 'Encoding & Unicode' do
  list:
    Регулярните изрази в Ruby 2.1 носят кодировката на сорс-кода
    Можете да проверите кодировката на даден регулярен израз с `Regexp#encoding`
    Можете да укажете изрична кодировка посредством модификатор; например `/something/u` за `UTF-8`
    Малък пример:

  blockquote.action
    | Rubyのお父さんはまつもとゆきひろさんです。

  .action
    example:
      unicode_test = 'Rubyのお父さんはまつもとゆきひろさんです。'

      /は[[:alpha:]]+さん/.match unicode_test # #<MatchData "はまつもとゆきひろさん">

= slide 'Граници на думи в Unicode-текст' do
  list:
    `\b` в Unicode-текст работи, когато границата на думата е лесно определима
    Например, това ще работи: `/\b[[:alpha:]]\b/.match 'това и онова' # #&lt;MatchData "и"&gt;`
    Горното работи, понеже думата на кирилица е оградена от интервали
    В някои езици, обаче, няма интервали (whitespace) между думите (например китайски, японски)
    Къде са границите на думите в това изречение: `Rubyのお父さんはまつもとゆきひろさんです。`?

= slide 'Граници на думи в Unicode-текст', 'пример' do
  p Например:
  div.action
    example:
      'Ruby no otousan ha Matsumoto Yukihiro san desu.'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Ruby] [no] [otousan] [ha] [Matsumoto] [Yukihiro] [san] [desu]."

  p.action Но:
  div.action
    example:
      'Rubyのお父さんはまつもとゆきひろさんです。'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Rubyのお父さんはまつもとゆきひろさんです]。"

= slide 'Флагове на шаблоните' do
  list:
    Можете да управлявате някои аспекти от поведението на шаблона посредством флагове
    Указват се след края на шаблона, например: `/pattern/flags`
    `i` прави търсенето на съвпадение нечувствително към регистъра на буквите
    `u` кара шаблона да носи задължителна кодировка `UTF-8`
    `m` превръща шаблона в multiline-такъв (в този режим, например, `.` ще съвпада и с нов ред)
    Има и други, които не се ползват толкова често

= slide 'Условия в шаблоните (if)', 'Ново в Ruby 2.0' do
  list:
    Ruby 2.0 и по-нови ползват библиотеката Onigmo за регулярни изрази
    Там има някои нововъведения, например това: `(?(cond)yes|no)`
    `cond` може да е референция към друга група в шаблона, или пък look-ahead/behind
    Пример:

  .action
    annotate:
      regexp = /^(number)?\s*(?(1)\d+|[a-zA-Z]+)$/

      regexp =~ "number 123"   # =>
      regexp =~ "foo"          # =>
      regexp =~ "number baz"   # =>

= slide 'Документация' do
  list:
    `Regexp`: <a href="http://www.ruby-doc.org/core-2.2.3/Regexp.html">http://www.ruby-doc.org/core-2.2.3/Regexp.html</a>
    `MatchData`: <a href="http://www.ruby-doc.org/core-2.2.3/MatchData.html">http://www.ruby-doc.org/core-2.2.3/MatchData.html</a>
    `String`: <a href="http://www.ruby-doc.org/core-2.2.3/String.html">http://www.ruby-doc.org/core-2.2.3/String.html</a>
    През `ri`, например: `ri Regexp#=~`

= slide 'Валидация на просто число с регулярен израз' do
  blockquote
    | Да се напише кратък Ruby expression, който проверява дали дадено число е просто или не,
      посредством употреба на регулярен израз. Резултатът от изпълнението му трябва да е <code>true</code>
      за прости числа и <code>false</code> за всички останали. Неща, които можете да ползвате:
    list:
      Самото число, разбира се.
      Произволни методи от класа `Regexp`
      Подходящ регулярен израз (шаблон)
      Текстовия низ `'1'`.
      `String#*`.
      Някакъв условен оператор (например `if`-`else` или `? … : …`)
      `true`, `false`, ...

= slide 'Решение на проверката за просто число с РИ' do
  list:
    Идеи, предложения?
    `'1' * числото =~ /някакъв регулярен израз/ ? false : true`
    `'1' * 13 =~ /^1?$|^(11+?)\1+$/ ? false : true`
    Много полезно знание :) Въпроси по израза?
    Регулярният израз тук може да се ползва 1:1 в Python за същата цел

= slide 'Въпроси?' do
  p Like any...
