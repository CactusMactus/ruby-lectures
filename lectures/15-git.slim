= slide 'Днес' do
  list:
    Ще се занимаваме с Git
    Ще погледнем под капака
    Ще го разберем

= slide 'Защо отделяме два часа, за да говорим за Git?' do
  list:
    Защото очевидно е нещо, което е необходимо и се ползва ежедневно
    Дори да си мислим, че го знаем, все ще има нещо ново, което ще научим
    Git e интересен пример за елегантно и семпло техническо решение на сравнително сложен проблем

= slide 'Version Control System (VCS)', 'Не просто система, следяща промени в код!' do
  list:
    Съхранение
    Сигурност - всичко е обратимо
    Лесна работа в екип
    Различни версии на кода
    Нещо, без което не можем

= slide 'Познавате ли този човек?' do
  img src="15/Linus-Torvalds.jpg"

  h2.action.center Linus Torvalds
  h2.action.center Бащата на Linux
  h2.action.center Създател на Git

= slide 'Малко история', 'Linux kernel' do
  list:
    15,803,499 реда код към юли 2013
    19,509,218 реда за Linux 4.1
    13,708 автора
    ~24 години история

  h2.action Какво е нужно?
  list:
    Бързина
    Много разклонения на кода
    Много възможности
    Децентрализация

= slide 'Централизирана VCS' do
  list:
    Един централен сървър
    Всички теглят и публикуват кода на него
    Локално се пазят само най-необходимите неща

= slide 'Децентрализирана VCS' do
  list:
    Всеки има копие на цялата история
    Често отново има един основен сървър...
    ...а може и изобщо да няма сървъри
    Почти всички операции се правят локално - не е необходима връзка с Интернет
    Когато решите - синхронизирате се с който и да е друг сървър

= slide 'Защо точно git?' do
  list:
    Гъвкавост
    Бързина
    Страшен на пръв поглед, може би и на втори
    Когато разберете как работи, ще ви озари ярка светлина и животът ви вече ще има смисъл
    Ще ви отнеме много време да откриете всичко, на което е способен
    Но не е нужно да знаете всичко, за да ви е полезен

= slide 'В началото беше git init' do
  example:
    git init
  p Създава празно хранилище в текущата директория.

  p.action Виждате папката <code>.git</code> - съхранява всичко, което е нужно за историята.

= slide 'Клониране на хранилище' do
  example:
    git clone https://github.com/fmi/ruby-lectures.git

  list:
    Компресия - сваля се бързо
    Поддържа и други протоколи като `file`, `ssh` и `git`

= slide 'Работната директория (working directory)' do
  list:
    Директорията на проекта - всичко без `.git`
    Текущата версия на файловете

= slide 'Хранилището' do
  list:
    Там се намират файловете, които се следят от Git
    Съхраняват се в `.git`

= slide 'Staging област' do
  list:
    Нарича се и индекс
    Междинна област между работната директория и хранилището
    Съхранява файловете, които ще отидат в следващия commit
    Просто един файл - `.git/index`

= slide 'Отдалечено хранилище' do
  list:
    Друго хранилище
    Най-често се намира на друг компютър
    Може да е просто друга `git` директория
    Локалното и отдалеченото хранилище се синхронизират чрез `git pull` и `git push`
    Може да има повече от едно такова
    А може и да няма нито едно

= slide 'Четирите области' do
  img src="15/git-flow.png"

= slide 'Четирите области' do
  list:
    Един файл може да е в повече от една област едновременно
    Възможно е този файл да е с различно съдържание във всяка една област
    Хранилищата съдържат много версии на един и същ файл

= slide '4 състояния на файл' do
  list:
    `Untracked` - няма версии на този файл в staging областта и локалното хранилище (нов файл)
    `Unmodified` - файлът е с еднакво съдържание в работната директория, staging и хранилището
    `Modified` - файлът е с различно съдържание в работната директория и staging
    `Staged` - файлът е с еднакво съдържание в работната директория и staging, но се различава в хранилището
    Ако не сме променили състоянието на файл в staging, то то е същото като в текущия commit в хранилището

= slide '4 състояния на файл' do
  img src="15/file-states.png"

= slide 'Staging областта', 'добавяне на файлове' do
  example:
    git add new_or_modified.rb
    git add lectures/11
    git add .
  list:
    Добавя един или повече файлове към staging областта.

= slide 'Staging областта', 'информация' do
  example:
    git status
  list:
    Списък с всички променени, изтрити и нови файлове.

= slide 'Staging областта', 'промени' do
  example:
    git diff
  list:
    Промени на файловете в работната директория, спрямо тези в staging областта.
    С опция <code>--staged</code> (<code>--cached</code> в по-стари версии) - промени на файлове в staging.

= slide 'Staging областта', 'изтриване на файлове' do
  example:
    git rm old.rb
  list:
    Изтрива файл от работната директория и го маркира като изтрит в staging.

= slide 'Staging областта', 'премахване на промени' do
  example:
    git reset new_or_modified.rb
    git reset lectures/11
  list:
    Премахва направени промени от staging.

= slide 'Типове обекти' do
  list:
    Файл (`blob`) - конкретна негова версия (snapshot), компресиран
    Дърво (`tree`) - списък от хешове на файлове и дървета
    `Commit` - за него след малко
    `Tag` - етикет, съдържащ идентификатора на конкретен commit
    Съхраняват се в `.git/objects`
    Всеки обект се идентифицира с `sha1` хеш от съдържанието си

= slide 'Commit', 'Конкретна версия на дърво (snapshot)' do
  p Една конкретна версия на кода.
  p.action Състои се от:
  list:
    Уникален идентификатор
    Автор и committer - може да са различни хора
    Съобщение
    Време на добавяне
    Хеш на предходния commit
    Хеш на дървото, за което се отнася
    Други метаданни

= slide 'История на промените' do
  example:
    git log
    git log --stat
    git log --since=2.weeks
    git log --since=5.days.15.minutes
    git log --until=2013-11-30
    git log --grep 'Proc.new'
    git log --author 'Dimitar Dimitrov'
    git log lectures/01-introduction-to-ruby.slim

= slide 'Commit', 'Да разгледаме' do
  example:
    git show 5fae69568cd5420e13a34c06f6f495ea9bcb9a4e
    git show 5fae695
    git show HEAD
    git show HEAD^
    git show HEAD^^^
    git show HEAD~3
    git diff HEAD~3..HEAD
  list:
    `HEAD` е указател към последния commit
    `HEAD^^^` - Броят стрелкички е поредният номер на commit-a (0 е най-скорошният)
    `HEAD~n` - същото като `HEAD^` с `n` на брой стрелкички

= slide 'Commit', 'Всичко е просто файл' do
  example:
    git cat-file -p 5fae695
  list:
    `5fae695` е част от хеша на commit-a

= slide 'Commit' do
  example:
    git commit
    git commit -m "Fix a typo on slide 3"
  p.action Commit-вайте възможно най-малките, логически свързани промени, които не чупят нищо.

= slide 'Commit съобщения' do
  list:
    Начин на комуникация с колегите
    Казват ви какво се е случило, докато ви е нямало
    Разкриват причини за бъгове
    Показват мотивацията за промяната

= slide 'Commit съобщения', 'Най-важното нещо във всяка VCS' do
  list:
    Първи ред - tl;dr версия. Възможно най-кратко и описателно - до 70 символа
    Останалите редове - допълнително описание
    Как сте разрешили определен бъг
    Каква е мотивацията да направите дадена промяна
    Какво е точното съобщение за грешка, което оправяте с този commit и прочее
    Сегашно време - все едно commit-ите говорят за себе си

= slide 'Commit съобщения', 'Лош пример' do
  pre Update Gemfile.lock

= slide 'Commit съобщения', 'Добър пример' do
  pre
    |
      Update skeptic and libv8

      The skeptic update showed errors in edge cases with the "spaces around
      operators" restriction.

      The libv8 update was because of compile problems I had with the older
      version on OS X Yosemite.

= slide 'Branch-ове (клони, разклонения)' do
  list:
    Независими разклонения на историята
    Например два фийчъра в процес на разработка
    В Git - файл, съдържащ хеш на commit
    Този commit се счита за последен в branch-a
    Нарича се връх на branch-а (branch tip)
    Първи елемент на свързан списък от commit-и

= slide 'Branch-ове' do
  img src='15/graph-branch.png'

= slide 'Branch-ове', 'Особености' do
  list:
    Branch по подразбиране - `master`
    `HEAD` всъщност е референция към текущия branch (файл, съдържащ името му)
    Локалните и отдалечените са различни - `master` vs `origin/master`
    Всъщност `origin/master` е локален branch, съответстващ на отдалечения. Ако го променим - отново трябва да push-нем
    `.git/refs/heads/<branch name>`

= slide 'Създаване на branch' do
  example:
    git branch killer-feature
    git checkout -b killer-feature
  h2 Превключване между вече създадени
  example:
    git checkout killer-feature
    git checkout master

= slide 'Създаване на branch' do
  img src='15/graph-branch-create.png'

= slide 'Демонстрация' do
  example:
    git branch
  list:
    Нов файл в `.git/refs/heads/`

= slide 'Обновяване' do
  example:
    git pull
    git pull origin
    git pull origin master
  list:
    Изтегля промените и ги слива с текущия branch

= slide 'Публикуване' do
  example:
    git push
    git push origin killer-feature
    git push origin local-branch-name:killer-feature # Ако са с различни имена
  list:
    `origin` е име на отдалечено хранилище - това, от което сме клонирали
    На мястото на `origin` може да стои името на което и да е отдалечено хранилище

= slide 'Сливане на разклонения' do
  example:
    git merge killer-feature
    git merge --squash killer-feature
  list:
    Слива промени от (най-често) 2 клона
    Често създава нов commit
  p.action Различни стратегии на сливане. Основните са 2:
  list:
    Fast-Forward
    Recursive

= slide 'Fast-Forward стратегия', 'Просто премества указателя за клона' do
  img src='15/graph-merge-ff-before.png'

= slide 'Fast-Forward стратегия', 'Просто премества указателя за клона' do
  img src='15/graph-merge-ff-after.png'

= slide 'Recursive стратегия' do
  p Слива 2 разделили се клона с обща история.
  img src='15/graph-branch-merge.png'

= slide 'Recursive стратегия' do
  p Жълтото e merge commit-a. Той съдържа промените и от двата клона.
  img src='15/graph-branch-merge-2.png'

= slide 'Обновяване 2' do
  example:
    git pull == git fetch && git merge origin/master
  list:
    Изтегля промените и ги слива с текущия бранч

= slide 'Изтриване на branch' do
  example:
    git branch -d killer-feature
    git push origin --delete killer-feature # Ако сте го push-нали
    git push origin :killer-feature         # В по-стари версии
  list:
    Премахва само файла на branch-a, commit-ите се пазят
    Дори ако е останал commit, който е извън историята, пак може да се възстанови
    За възстановяване - след малко

= slide 'Изтриване на branch' do
  img src='15/graph-branch-delete.png'

= slide 'Типичен процес на работа' do
  p Заради "евтините" branch-ове на git можем да направим следното:
  list:
    Имаме два основни branch-a - `master` и `develop` (`internal`, `unstable` или както го кръстите)
    Когато започваме нова функционалност, правим branch специално за тази промяна
    Когато приключим, я качваме в `develop` с `git merge`
    В `develop` нещата се тестват и след определено време се сливат с `master`
    Аналогично е и `master` + `production`

= slide 'Типичен процес на работа' do
  img src='15/branching-workflow.png'

= slide 'Типичен процес на работа', 'Резултат' do
  list:
    В `master` има само стабилни промени
    В `develop` има нови функции
    Ако две нови функции си пречат, това може да се поправи, преди да влязат в стабилната версия
    Ако трябва бързо да поправим нещо в стабилната версия на кода, можем директно да направим commit в `master`

= slide 'Машината на времето', 'Или как да върнем загубени промени.' do
  example:
    git reset
    git checkout
    git commit --amend
    git revert
    git reflog

= slide 'Машината на времето' do
  example:
    git reset <commit> <files>
    git reset HEAD lectures/git.slim
  list:
    Променя файлове в staging областта, като ги взима от хранилището
    В случая `HEAD` указва от кой точно commit да се вземат файловете. Там може да има и хеш на commit
    <strong>Не променя</strong> файловете в работната директория
    Използва се, когато не искате да commit-вате файл, но да запазите локалните промени
    С `--hard` променя и работната директория

= slide 'Машината на времето' do
  example:
    git checkout <files>
    git checkout <commit> <files>
    git checkout <branch> <files>
  list:
    Променя файлове в работната директория, като ги взима от staging областта...
    ... или от определен commit.
    Внимание! Може да изгубите код, който не е commit-нат!

= slide 'Машината на времето' do
  example:
    git commit --amend
    git push --force origin branch  # Ако вече сте push-нали
  list:
    Променя последния commit
    Всъщност създава нов commit със същия предшественик
    Старият commit все още може да бъде възстановен
    Удобно е за поправяне на грешки в съобщението или добавяне на изпуснати файлове
    Не е хубаво да се прави, ако вече сте push-нали, защото някой друг може да е направил pull и ще има конфликт
